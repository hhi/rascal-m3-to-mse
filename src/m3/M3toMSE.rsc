module m3::M3toMSE

/*
MSE is currently generated by directly spitting out strings.
None of this code is tested. Instead, FAMIX entities should be
generated within Rascal, and then the generated model should be
translated to MSE. Then we can write tests for the model generation.
*/


/* === IMPORTS ===*/

import lang::java::jdt::m3::Core;

import analysis::m3::metrics::LOC;

import lang::java::m3::TypeHierarchy;
import lang::java::m3::TypeSymbol;
import IO;
import Set;
import List;
import Relation;
import String;
import Node;
import util::Benchmark;

/* === MSE GENERATION === */

/*
import util::ValueUI;
sm = snakes();
writeMSE(sm);
bmWriteMSE(sm);

import lang::java::jdt::m3::Core;
M3 re;
import util::Benchmark;
realTime(void () { re = createM3FromEclipseProject(|project://rascal-eclipse|); });
realTime(void () { writeMSE(re); });

bmWriteMSE(re);

import lang::java::jdt::m3::Core;
M3 rm;
import util::Benchmark;
realTime(void () { rm = createM3FromEclipseProject(|project://rascal-clone|); });
realTime(void () { writeMSE(rm); });

bmWriteMSE(rm);

*/

@doc { Write the MSE for an Eclipse Java project to its source directory. }
public void writeMSE(M3 m) {
	loc file = m.id + "<m.id.authority>.mse";
	writeFile(file, "(\n");
	appendPackages(file, m);
	appendClasses(file, m);
	appendInheritance(file, m);
	appendPrimitiveTypes(file, m);
	appendImportedTypes(file, m);

	appendAttributes(file, m);
	appendAccesses(file, m);

	appendMethods(file, m);
	appendParameters(file, m);
	appendInvocation(file, m);
	// appendFileAnchors(file, m); // TODO
	appendToFile(file, ")\n");
}

@doc { Benchmarked version of the above. }
public void bmWriteMSE(M3 m) {
	loc file = m.id + "<m.id.authority>.mse";
	writeFile(file, "(\n");
	map[str,num] results = benchmark( (
		"appendPackages" : void() {appendPackages(file, m);},
		"appendClasses" : void() {appendClasses(file, m);},
		"appendInheritance" : void() {appendInheritance(file, m);},
		"appendPrimitiveTypes" : void() {appendPrimitiveTypes(file, m);},
		"appendImportedTypes" : void() {appendImportedTypes(file, m);},
		"appendAttributes" : void() {appendAttributes(file, m);},
		"appendAccesses" : void() {appendAccesses(file, m);},
		"appendMethods" : void() {appendMethods(file, m);},
		"appendParameters" : void() {appendParameters(file, m);},
		"appendInvocation" : void() {appendInvocation(file, m);}
		// "appendFileAnchors" : void() {appendFileAnchors(file, m);}
	) );
	appendToFile(file, ")\n");
	for (str key <- results) {
		println("<key> : <results[key]> ms");
	}
}

private void appendPackages(loc file, M3 m) {
	for (loc p <- packages(m) + { unknownPackage(m.id) }) {
		appendToFile(file,
			"	(FAMIX.Namespace (id: <getID(m,p)>)
			'		(name \'<replaceFirst(p.path,"/","")>\'))
			'");
		// TODO: (isStub true)
		// TODO: (parentScope (ref: ID))
	}
}

private void appendClasses(loc file, M3 m) {
	for (loc c <- classes(m) + interfaces(m) + anonClasses(m)) {
		appendToFile(file,
			"	(FAMIX.Class (id: <getID(m,c)>)
			'		(name \'<getClassName(c)>\')
			'		(container (ref: <getID(m, getClassPackage(m, c))>))
			'		(isInterface <isInterface(c)?true:false>))
			'");
		//	'		(sourceAnchor (ref: <getID(m, getSource(m, c))>)))
		// TODO: (modifiers 'public')
	}
}

private void appendInheritance(loc file, M3 m) {
	for (<loc subclass, loc superclass> <- m@implements + m@extends) {
		appendToFile(file,
			"	(FAMIX.Inheritance (id: <getID(m,<subclass,superclass>)>)
			'		(subclass (ref: <getID(m, subclass)>))
			'		(superclass (ref: <getID(m, superclass)>)))
			'");
		// TODO: (previous (ref: 601))
	}
}

private void appendPrimitiveTypes(loc file, M3 m) {
	for (TypeSymbol t <- primitiveTypes(m)) {
		appendToFile(file,
			"	(FAMIX.PrimitiveType (id: <getID(m,t)>)
			'		(name \'<primitiveTypeName(t)>\')
			'		(isStub true))
			'");
	}
}

private void appendImportedTypes(loc file, M3 m) {
	for (loc c <- importedTypes(m)) {
		appendToFile(file,
			"	(FAMIX.Class (id: <getID(m,c)>)
			'		(name \'<getClassName(c)>\')
			'		(container (ref: <getID(m, getClassPackage(m, c))>))
			'		(isInterface <isInterface(c)?true:false>)
			'		(isStub true))
			'");
	}
	// TODO: check for ParameterizedType instead of Class
}

private void appendAttributes(loc file, M3 m) {
	// for (loc f <- fields(m) + externalFields(m)) {
	// M3 can't find parent of external field, so skip for now.
	for (loc f <- fields(m)) {
	// println("FIELD <f>\n");
		appendToFile(file,
			"	(FAMIX.Attribute (id: <getID(m,f)>)
			'		(name \'<getFieldName(f)>\')
			'		(declaredType (ref: <declaredTypeID(m,f)>))
			'		(parentType (ref: <getID(m,getParent(m,f))>)))
			'");
		// TODO: (declaredTS (ref: 55))
		// TODO: (hasClassScope true)
		// TODO: (isStub true)
		// TODO: (modifiers 'final' 'public')
		// TODO: (getParent (ref: 767)))
		// TODO: (sourceAnchor (ref: 670))
	}
}

private void appendAccesses(loc file, M3 m) {
	// Skip external fields for now (missing parent info)
	for (a:<loc acc, loc field> <- m@fieldAccess, !isExternalField(m, field)) {
		if (isVariable(acc)) {
			acc = getParent(m, acc);
		}
		if (getMethodSignature(acc) == "play(snakes.Die)") {
			println("DEBUG <acc> accesses <field>");
		}
		if (isMethod(acc)) {
			appendToFile(file,
				"	(FAMIX.Access (id: <getID(m,a)>)
				'		(accessor (ref: <getID(m,acc)>))
				'		(variable (ref: <getID(m,field)>)))
				'");
		}
		// TODO: (sourceAnchor (ref: <getID(m, getSource(m, field))>)))
		// NB: only for declared fields	
	}
}

private void appendMethods(loc file, M3 m) {
	// M3 does not yet support a way to navigate from external methods
	// to their parent type, so leave them out for now
	// for (meth <- methods(m) + externalMethods(m)) {
	for (meth <- methods(m)) { 
	// println("METHOD <meth>\n");
		if (isConstructor(meth)) {
			appendToFile(file,
			"	(FAMIX.Method (id: <getID(m,meth)>)
			'		(name \'<getMethodName(meth)>\')
			'		(kind \'constructor\')
			'		(numberOfLinesOfCode <sloc(m,meth)>)
			'		(parentType (ref: <getID(m,getParent(m,meth))>))
			'		(signature \'<getMethodSignature(meth)>\'))
			'");
			// '		(sourceAnchor (ref: <getID(m, getSource(m, meth))>)))
		} else {
			appendToFile(file,
			"	(FAMIX.Method (id: <getID(m,meth)>)
			'		(name \'<getMethodName(meth)>\')
			'		(declaredType (ref: <getID(m,returnType(m,meth))>))
			'		(numberOfLinesOfCode <sloc(m,meth)>)
			'		(parentType (ref: <getID(m,getParent(m,meth))>))
			'		(signature \'<getMethodSignature(meth)>\'))
			'");
			// '		(sourceAnchor (ref: <getID(m, getSource(m, meth))>)))
		}
		// TODO: (modifiers \'protected\')
		// TDOO: (cyclomaticComplexity NNN)
	}
}

private void appendParameters(loc file, M3 m) {
	for (p <- parameters(m)) {
	// println("PARAM <p>\n");
		appendToFile(file,
			"	(FAMIX.Parameter (id: <getID(m,p)>)
			'		(name \'<getFieldName(p)>\')
			'		(declaredType (ref: <declaredTypeID(m,p)>))
			'		(parentBehaviouralEntity (ref: <getID(m,getParent(m,p))>)))
			'");
	}
}

/*
TODO: Fix bug in invocations

|java+constructor://p2-SnakesAndLadders/snakes/Square/Square(snakes.Game,int)|
"called by"
|java+variable://p2-SnakesAndLadders/snakes/Game/addSquares(int)/square|
in method
|java+method://p2-SnakesAndLadders/snakes/Game/addSquares(int)|

The code correctly finds the enclosing method (addSquares()) and gives it as the sender.
When this is imported into Moose, however, the invoker is shown as nil.
(Click on the Square class to provoke the exception.)

*/

private void appendInvocation(loc file, M3 m)  {
	for (inv:<loc sender, loc meth> <- m@methodInvocation) {
	
		if (isVariable(sender)) {
			sender = getParent(m, sender);
		}
		
		// Apparently variables can also be invokers ...
		if (isMethod(sender) && isMethod(meth) && !isExternalMethod(m, meth)) {
			appendToFile(file,
			"	(FAMIX.Invocation (id: <getID(m,inv)>)
			'		(candidates (ref: <getID(m,meth)>))
			'		(sender (ref: <getID(m,sender)>))
			'		(signature \'<getMethodSignature(meth)>\'))
			'");
		}
		// TODO: previous -- not available in M3
		// TODO: receiver (PARAMETER etc) -- not yet available in M3
	}
}

/*
private void appendFileAnchors(loc file, M3 m) {
	for (elt <- m@declarations<0>) {
		loc src = getSource(m,elt);
		appendToFile(file,
		"	(FAMIX.FileAnchor (id: <getID(m,src)>)
		'		(element (ref: <getID(m,elt)>)
		'		(fileName \'<src.path>\'))
		'");
		// '		(startLine <src.begin.line>)
		// '		(endLine <src.end.line>)
	}
} // TODO
*/

/* === IDs === */

@doc { Returns a map from FAMIX entity values to unique IDs. }
@memo public map[value,int] idMap(M3 m) {
	set[value] entities = m@declarations<0> + m@declarations<1> // classes, methods, attributes
						+ primitiveTypes(m) // NB: TypeSymbols; all others are locations
						+ importedTypes(m)
						+ { unknownFieldType() }
						+ m@methodInvocation<1> // external methods
						+ m@fieldAccess<1> // external fields
						+ m@extends + m@implements // inheritances
						+ m@methodInvocation
						+ m@fieldAccess
						+ importedPackages(m);
						// TODO: need also imported and used types of fields, methods etc
	return index(entities);
}

private &T rprintln(&T v) {
	println(v);
	return v;
}

@doc { Returns the ID of a FAMIX entity }
public int getID(M3 m, value entity) = idMap(m)[entity]; // convenience

@doc { Returns the source URI for the method or class URI. }
public loc getSource(M3 m, loc method) = getUniqueElement(sourceLocMap(m)[method]);
@doc { Returns unique element of a set, or fails. }
private &T getUniqueElement(set[&T] s) {
	assert size(s) == 1;
	return getOneFrom(s);
}

@doc { Return map of declarations; memoized for performance. }
@memo private map[loc, set[loc]] sourceLocMap(M3 m) = toMap(m@declarations);

/* === CLASSES, PACKAGES === */

@doc { Return the package URI for a given class URI. }
// private loc getClassPackage(M3 m, loc c) = |java+package://<c.authority><getPackageName(c)>|;
public loc getClassPackage(M3 m, loc c) {
	set[loc] parents = parents(m)[c]?{};
	if (isEmpty(parents)) {
		return unknownPackage(c);
	}
	loc parent = getUniqueElement(parents);
	return isPackage(parent) ? parent : getClassPackage(m, parent);
}
test bool snakePackage() = getClassPackage(snakes(), snakeClass) == snakePackage;

@doc { Memoize conversion to map for performance.}
@memo public map[loc,set[loc]] parents(M3 m) = toMap(invert(m@containment));

// public loc unknownPackage(loc c) = |java+package://<c.authority>/unknown|;
public loc unknownPackage(loc c) = |java+package://UNKNOWN_PACKAGE|;

@doc { Return the package name for a class URI. }
private str getPackageName(loc c) = dropPathSuffix(c.path, "/");
test bool snakePackageName() = getPackageName(snakeClass) == "/snakes";

@doc { Return the class name for a given class URI. }
private str getClassName(loc c) = getPathSuffix(c.path);
test bool snakeClassName() = getClassName(snakeClass) == "Snake";

/* === FIELDS === */

@doc { Return the field name for a given field URI. }
public str getFieldName(loc f) = getPathSuffix(f.path);
test bool testGetFieldName() = getFieldName(squaresField) == "squares";

@doc { Return parent (containing) type of a field, method or parameter.
Also returns containing method of a variable. }
public loc getParent(M3 m, loc f) = getUniqueElement(parents(m)[f]);

//private loc getParent(loc f) = |java+class://<f.authority><dropPathSuffix(f.path, "/")>|;

test bool squaresFieldParentType() = getParent(snakes(), squaresField) == gameClass;
test bool winnerFieldParentType() = getParent(snakes(), winnerField) == gameClass;
test bool winnerMethodParentType() = getParent(snakes(), setSquare) == gameClass;
test bool leaveMethodParentType() = getParent(snakes(), leaveISquare) == squareIfc;

test bool squareParamParentType() = getParent(snakes(), squareParam) == setSquare;

@doc { Return declared type of a field. }
public TypeSymbol declaredTS(M3 m, loc f) = getUniqueElement(typeOf(m)[f]);
test bool squaresFieldType() = declaredTS(snakes(), squaresField) == listISquareTS;
test bool winnerFieldType() = declaredTS(snakes(), winnerField) == playerTS;

@doc { Return type(s) of an entity; memoized map for performance. }
@memo private map[loc,set[TypeSymbol]] typeOf(M3 m) = toMap(m@types); // post: size == 1

@doc { Return the ID of the type of a field. }
public int declaredTypeID(M3 m, loc f) {
	try
		TypeSymbol ts = declaredTS(m, f);
	catch :
		return getID(m, unknownFieldType());
	if (isPrimitive(ts)) {
		return getID(m, ts);
	}
	// return getID(m, getUniqueElement(locations(ts)));
	return getID(m, location(ts));
}

@doc { Returns unknown type placeholder for fields with missing type .}
private loc unknownFieldType() = |java+class://UNKNOWN_PACKAGE/UNKNOWN_TYPE|;

@memo public set[loc] externalFields(M3 m) = m@fieldAccess<1> - fields(m);
public bool isExternalField(M3 m, loc f) = f in externalFields(m);
test bool testExternalField() = isExternalField(snakes(), systemOut);

/* === TYPES === */

private bool isPrimitive(\int()) = true;
private bool isPrimitive(\float()) = true;
private bool isPrimitive(\double()) = true;
private bool isPrimitive(\short()) = true;
private bool isPrimitive(\boolean()) = true;
private bool isPrimitive(\char()) = true;
private bool isPrimitive(\byte()) = true;
private bool isPrimitive(\long()) = true;
private bool isPrimitive(\void()) = true;
private bool isPrimitive(\null()) = true;
private bool isPrimitive(\array(_,_)) = true;
private bool isPrimitive(\typeParameter(_, _)) = true; // TODO: treat as an entity, not a primitive?
private default bool isPrimitive(TypeSymbol s) = false;

test bool testPrimitive1() = isPrimitive(\int());
test bool testPrimitive2() = !isPrimitive(playerTS);

public set[TypeSymbol] primitiveTypes(M3 m) =
	  { t | t <- types(m), isPrimitive(t) }
	+ { t | t <- returnTypes(m), isPrimitive(t) }
	+ { t | t <- parameterTypes(m), isPrimitive(t) };
test bool snakePrimitiveTypes() = \int() in primitiveTypes(snakes());

public str primitiveTypeName(TypeSymbol s) {
	assert(isPrimitive(s));
	return getName(s);
}
test bool testPrimitiveName() = primitiveTypeName(\int()) == "int";
test bool testNotPrimitive() {
	try {
		str result = primitiveTypeName(playerTS);
		return false;
	}
	catch : return true;
}

// \method(loc decl, list[TypeSymbol] typeParameters, TypeSymbol returnType, list[TypeSymbol] parameters)
// \constructor(loc decl, list[TypeSymbol] parameters)
// \wildcard(Bound bound)
// \capture(Bound bound, TypeSymbol wildcard)
// \intersection(list[TypeSymbol] types)
// \union(list[TypeSymbol] types)


/*
Alternatively: precondition should be that argument is non-primitive, and post returns the decl
*/

public set[loc] locations(class(loc decl, _)) = { decl };
public set[loc] locations(interface(loc decl, _)) = { decl };
public set[loc] locations(method(loc decl, _, _, _)) = { decl };
public set[loc] locations(constructor(loc decl, _)) = { decl };
public set[loc] locations(enum(loc decl)) = { decl };
public set[loc] locations(typeParameter(decl,_)) = { decl };
public set[loc] locations(object()) = { unknownFieldType() }; // TEMPORARY HACK
public default set[loc] locations(TypeSymbol _) = {};
test bool testLocations1() = locations(\int()) == {};
test bool testLocations2() = locations(playerTS) == {playerClass};
test bool testLocations3() = locations(setSquareTS) == {setSquare};

public loc location(TypeSymbol ts) {
	assert(!isPrimitive(ts));
	return getUniqueElement(locations(ts));
}

@doc { Returns the locations of a set of TypeSymbols. }
public set[loc] locationsOf(set[TypeSymbol] tsSet) {
	return { location(ts) | ts <- tsSet, !isPrimitive(ts) };
}

@doc { Returns imported classes and interfaces, i.e., used, but not declared. }
public set[loc] importedTypes(M3 m) =
	usedTypes(m)
	+ superTypes(m)
	+ locationsOf(returnTypes(m))
	+ locationsOf(parameterTypes(m))
	- m@declarations<0>;
public set[loc] superTypes(M3 m) = m@extends<1> + m@implements<1>;
public set[loc] usedTypes(M3 m) =
		  { decl | \class(decl, _) <- types(m)}
		+ { decl | \interface(decl, _) <- types(m)};
test bool testImportedTypes() = size(importedTypes(snakes())) == 4;
test bool testSuperTypes() = superTypes(snakes()) == { ladderClass, squareClass, squareIfc };

private bool isImported(M3 m, loc t) = t in importedTypes(m);
test bool testIsImported() = isImported(snakes(), listInterface);

public set[loc] importedPackages(M3 m) {
	return { getClassPackage(m, c) | c <- importedTypes(m) };
}
test bool testImportedPackages() = size(importedPackages(snakes())) == 1;

/* === METHODS === */

@doc {Return just the method name. }
public str getMethodName(loc m) {
	return dropPathSuffix(getPathSuffix(m.path), "(");
}
test bool testSetSquareName() = getMethodName(setSquare) == "setSquare";

@doc { Return the method signature for a given field URI. }
private str getMethodSignature(loc m) = getPathSuffix(m.path);
test bool testMethodSignature() = getMethodSignature(setSquare) == "setSquare(int,snakes.ISquare)";

@doc { Return the return type of a method. If primitive, returns the TypeSymbol. }
public value returnType(M3 m, loc meth) {
	try {
		TypeSymbol ts = getUniqueElement({rt | \method(_, _, TypeSymbol rt, _) <- typeOf(m)[meth]});
		return isPrimitive(ts) ? ts : location(ts);
	}
	catch :
		return unknownFieldType();
}
test bool testSetSquareType() = returnType(snakes(), setSquare) == \void();

public set[TypeSymbol] returnTypes(M3 m) = { rt | \method(_, _, TypeSymbol rt, _) <- types(m) };
public set[TypeSymbol] parameterTypes(M3 m) = ( {} | it + e | e <- { toSet(pt) | \method(_, _, _, list[TypeSymbol] pt) <- types(m) });

@doc { Return the type symbols of types defined in m . }
public set[TypeSymbol] types(M3 m) = m@types<1>;

bool isConstructor(loc entity) = entity.scheme == "java+constructor";
test bool testIsConstructor() = isConstructor(squareConstructor); 
test bool testIsNotConstructor() = !isConstructor(leaveISquare); 

@memo public set[loc] externalMethods(M3 m) = m@methodInvocation<1> - methods(m);
public bool isExternalMethod(M3 m, loc meth) = meth in externalMethods(m);
test bool testExternalMethods() = isExternalMethod(snakes(), setList);

@doc { Returns all classes of declared methods. }
public set[loc] anonClasses(M3 m) =
	{ getParent(m, meth) | meth <- methods(m) } - classes(m) - interfaces(m);


@doc { Returns count of Source Lines of Code for a method or other source entity. }
public int sloc(M3 m, loc elt) {
	loc src = getSource(m,elt);
	return 1 + src.end.line - src.begin.line;
}
test bool testSLOC1() = sloc(snakes(), setSquare) == 7; 
test bool testSLOC2() = sloc(snakes(), squareIfc) == 10; 

/* === UTILITIES === */

@doc { Return the last component of a path. }
private str getPathSuffix(str path) {
	assert(contains(path, "/"));
	return substring(path, 1+findLast(path, "/"));
}
test bool testGetPathSuffix() = getPathSuffix("/a/b/c/d/e") == "e";

@doc { Drop the last component of a path. }
private str dropPathSuffix(str path, str suffix) {
	assert(contains(path, suffix));
	return substring(path, 0, findLast(path, suffix));
}
test bool testDropPathSuffix() = dropPathSuffix("/a/b/c/d/e", "/") == "/a/b/c/d";

/* === DEBUGGING === */

@doc { Reports where a certain value is found in an M3 model. }
public void whereIs(M3 m, value v) {
	// module analysis::m3::Core
	reportRelPresence(v, m@declarations, "m@declarations");
	reportRelPresence(v, m@types, "m@types");
	reportRelPresence(v, m@uses, "m@uses");
	reportRelPresence(v, m@containment, "m@containment");
	reportPresence(v, toSet(m@messages), "m@messages");
	reportRelPresence(v, m@names, "m@names");
	reportRelPresence(v, m@containment, "m@containment");
	reportRelPresence(v, m@documentation, "m@documentation");
	reportRelPresence(v, m@modifiers, "m@modifiers");
	
	// module lang::java::m3::Core
	reportRelPresence(v, m@extends, "m@extends");
	reportRelPresence(v, m@implements, "m@implements");
	reportRelPresence(v, m@methodInvocation, "m@methodInvocation");
	reportRelPresence(v, m@fieldAccess, "m@fieldAccess");
	reportRelPresence(v, m@typeDependency, "m@typeDependency");
	reportRelPresence(v, m@methodOverrides, "m@methodOverrides");
}

private void reportRelPresence(value v, rel[value, value] m, str d) {
	reportPresence(v, m<0>, "<d>\<0\>");  
	reportPresence(v, m<1>, "<d>\<1\>");  
}	

private void reportPresence(value v, set[value] s, str d) {
	if (v in s) {
		println("Found <v> in <d>");
	}
}

/* === TEST FIXTURES === */

@memo public M3 snakes() = createM3FromEclipseProject(|project://p2-SnakesAndLadders|);

private loc squareClass = |java+class://p2-SnakesAndLadders/snakes/Square|;
private loc ladderClass = |java+class://p2-SnakesAndLadders/snakes/Ladder|;
private loc snakeClass = |java+class://p2-SnakesAndLadders/snakes/Snake|;
private loc squareIfc = |java+interface://p2-SnakesAndLadders/snakes/ISquare|;
private loc snakePackage = |java+package://p2-SnakesAndLadders/snakes|;
private loc squaresField = |java+field://p2-SnakesAndLadders/snakes/Game/squares|;
private loc winnerField = |java+field://p2-SnakesAndLadders/snakes/Game/winner|;
private loc gameClass = |java+class://p2-SnakesAndLadders/snakes/Game|;
private loc playerClass = |java+class://p2-SnakesAndLadders/snakes/Player|;
private loc listInterface = |java+interface://p2-SnakesAndLadders/java/util/List|;
private loc squareConstructor = |java+constructor://p2-SnakesAndLadders/snakes/Square/Square(snakes.Game,int)|;
private loc leaveISquare = |java+method://p2-SnakesAndLadders/snakes/ISquare/leave(snakes.Player)|;

private loc setSquare = |java+method://p2-SnakesAndLadders/snakes/Game/setSquare(int,snakes.ISquare)|;
private loc squareParam = |java+parameter://p2-SnakesAndLadders/snakes/Game/setSquare(int,snakes.ISquare)/square|;

private loc setList = |java+method://p2-SnakesAndLadders/java/util/List/set(int,E)|;
private loc systemOut = |java+field://p2-SnakesAndLadders/java/lang/System/out|;

private TypeSymbol playerTS = class(playerClass, []);
private TypeSymbol listISquareTS = interface(listInterface, [interface(squareIfc, [])]);
private TypeSymbol setSquareTS = declaredTS(snakes(), setSquare);

/* === EOF === */
